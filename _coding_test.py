# # 철수는 해외여향 자금 마련을 위해 아르바이트를 하려고 합니다. 모든 아르바디트는 시작 날자와 끝 날자가 정해져 있으며, 급여도 제각각입니다. 철수는 최대한 많은 돈을 벌기 위해 아르바이트를 여러개 하려고 합니다. 단, 아르바이트를 동시에 두 개 이상 할 수는 없으며, 아르바이트가 끝나는 날 다른 아르바이트를 시작하는 것은 가능합니다.
# # 각 아르바이트의 시작 날짜와 끝 날짜, 급여가 담긴 배열 part_times가 매개변수로 주어질 때, 철수가 최대로 벌 수 있는 돈은 얼마인지 return 하도록 solution 함수를 완성해 주세요
#
# # 제한 사항
# # part_times는 2차원 배열입니다.
# # part_times의 세로(행) 길이는 1 이상 15 이하입니다.
# # part_times의 가로(열) 길이는 3입니다.
# # part_times의 원소는 [S,E,C] 형태입니다.
# # S는 아르바이트 시작일, E는 아르바이트 종료일, C는 해당 아르바이트의 급여를 나타냅니다.
# # S는 항상 E보다 작습니다.
# # S와 E는 1이상 100이하인 자연수 입니다.
# # C는 1 이상 1000 이하인 자연수입니다.
# # 입출력 예 1
# part_times = [[3,6,3],[2,4,2],[10,12,8],[11,15,5],[1,8,10],[12,13,1]]
# result = 19
# # 입출력 예 2
# part_times = [[1,2,1],[1,2,2],[2,3,1],[3,4,1],[1,4,2]]
# result = 4
from bisect import bisect_right


def solution(part_times):
    # 아르바이트를 종료 날짜 기준으로 정렬
    part_times.sort(key=lambda x: x[1])

    # 종료 날짜 기준으로 dp 배열 준비
    n = len(part_times)
    dp = [0] * n  # dp[i]는 i번째 아르바이트까지 고려한 최대 수익

    # 첫 번째 아르바이트의 수익으로 초기화
    dp[0] = part_times[0][2]
    print(dp)
    # 각 아르바이트에 대해 최적의 수익 계산
    for i in range(1, n):
        # 현재 아르바이트 선택
        profit = part_times[i][2]
        print("프로핏",profit)
        # 현재 아르바이트와 겹치지 않는 가장 가까운 아르바이트 찾기
        # 이분 탐색을 통해 찾음
        # -1 스탭씩 움직이니까 역순으로 찾기
        for j in range(i - 1, -1, -1):
            print(part_times)
            print(j, part_times[j][0],part_times[i][0])

            if part_times[j][1] < part_times[i][0]:
                profit += dp[j]
                break

        # 이전까지의 최대 수익과 현재 선택한 수익을 비교
        dp[i] = max(dp[i - 1], profit)

    # dp 테이블의 최댓값이 최종 결과
    return dp[-1]


# 테스트
print(solution([[3, 6, 3], [2, 4, 2], [10, 12, 8], [11, 15, 5], [1, 8, 10], [12, 13, 1]]))  # 결과: 19
# print(solution([[1, 2, 1], [1, 2, 2], [2, 3, 1], [3, 4, 1], [1, 4, 2]]))  # 결과: 4
