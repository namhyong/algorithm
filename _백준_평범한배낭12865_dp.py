# 필요한 물건 N개
# 무게 W, 가치 V -> 해당 물건을 가져가면 V만큼 즐길 수 있음
# 무게 제한 K

import sys
import copy
input = sys.stdin.readline
N,K = map(int,input().split())
WV = [list(map(int,input().split())) for _ in range(N)]
# 현재 무개에 들어갈수 있는 값들을 비교
dp  = [0]*(K+1)
# 메인 아이디어:
# W값을 돌면서 해당 W부터 다음 무게제한 K까지 값을 넣어가면서 비교함
# 기존에 배낭에 넣어놨던 물건 무게와 현재 W를 빼고 난 나머지를 적재했던(for문으로 돌고있는 무게-W)를하여
# 지금 물건과 나머지 물건(이때 나머지 물건은 dp로 돌았기 때문에 현재 상황에서 적재할 수 있는 최대 값임)의 합 값을 구해 dp를 업데이트 시킴
# for W,V in WV:
#     check_prev = dp[:] # 한개의 dp만 사용할 경우 사용한 물건을 중복으로 적재하는경우가 생기기 때문에 이전에 값을 비교해야 함
#     # 예를들어 무게가 1이고 가치가 10이라면 이전 값 비교하면면서 계속 10씩 늘어나기 때문에 처음에 0으로 초기화된 prev_dp를 이용하는거임
#     for i in range(W,K+1):
#         dp[i] = max(dp[i],check_prev[i-W]+V)
# 역순으로 탐색하면 앞 값이 먼저 바뀌지 않기 때문에 리스트 하나로도 해결 가능함
# 즉, 기존처럼 먼저 시작하면 현재 탐색하는 W가 최적의 V라 적재했는데 마지막에 가서 차이 값이 처음 시작한 W라서 W를 두 번 적재하는 경우가 발생할수도 있는거임
# 하지만, 역순으로 하면 마지막에 최적값이라 적재했다면 한번 적재한걸로 인식되고 점차 무게를 줄여가더라도 뒤에 값은 고려사항이 이니기 때문에 문제가 없다
for W,V in WV:
    for i in range(K,W-1,-1):
        dp[i] = max(dp[i],dp[i-W]+V)
print(dp[-1])
# [[0, 0, 0, 0, 0, 0, 0, 0],
#  [0, 0, 0, 0, 0, 0, 13, 13],
#  [0, 0, 0, 0, 8, 8, 13, 13],
#  [0, 0, 0, 6, 8, 8, 13, 0],
#  [0, 0, 0, 0, 0, 0, 0, 0]]
# [[0, 0, 0, 6, 8, 8, 13, 13]]
# 6 13
# 4 8
# 3 6
# 5 12

#반례
# 4 7
# 1 2
# 2 7
# 3 3
# 4 4