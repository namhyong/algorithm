import sys
input = sys.stdin.readline

N,K = map(int,input().split())

dp = [[1]*(N+1) for _ in range(K)]
for i in range(1,K):
    for j in range(1,N+1):
        dp[i][j] = (dp[i-1][j]+dp[i][j-1])%1000000000
print(dp[K-1][N])
print(dp)
# 1~ N까지 각각 숫자 K개로 만들수 있는 경우의 수를 기록
# 예를들어 6,4 의 경우 1~4개의 숫자를 사용해 1~ 6까지 만드는 경우의 수를 기록
# 첫째줄은 한 개의 숫자를 이용해 0~ 6까지 만드는 경우의 수를 기록하기 때문에
# 한개의 수를 쓰려면 해당 숫자에 해당 하는 자기 자신과 나머지는 0으로 채워야 하는 방법 하나 밖에 없기 때문에 모두다 1가지 방법으로 초기화 된다
# 이후 2개의 숫자를 이용해 해당 숫자를 만드는 방법은 1개의 숫자를 이용해 현재 구하려는 숫자보다 작거나 같은 수를 만드는 방법들을 모두 합치는 것이다
# 예를들어 1개의 숫자로 0을 만드는 방법이 1개 2개의 숫자로 0을 만드는 방법도 1개라면, 2개의 숫자를 이용해 1을 만드는 방법은 1개 숫자들로 값을 만드는 방법들의 합
# 즉, 1+1이 된다
# 2개의 숫자로 2를 만드는 방법은 1개의 숫자로 만드는 0~2까지의 방법 개수의 합이다
# 하지만 0~1까지의 합은 2개의 숫자로 1을 만드는 방법에 이미 합해져 있기 때문에 이전 dp인 dp[i][j-1]을 보면 알 수 있고
# 1개의 숫자로 지금 찾으려 하는 숫자를 만드는 방법값만 찾아서 더해주면 되기 때문에 이전 열인 dp[i-1][j]를 찾아서 더해주면 된다.
# 따라서 3개 숫자로 2를 만드는 방법은 0~2 까지 숫자 2개로 만드는 방법들의 합과 같지만, 0~1까지는 이전 for문에서 합의 값을 기록했기 때문에
# dp[i][j-1] =3 에서 찾을 수 있고, 나머지 2의 값은 dp[i-1][j]=3값으로 찾을 수 있기 때문에 두 값의 합인 6이 dp[i][j]가 된다.
#     0  1  2  3  4  5  6 N
# 1 [[1, 1, 1, 1, 1, 1, 1],
# 2 [1, 2, 3, 4, 5, 6, 7],
# 3 [1, 3, 6, 10, 15, 21, 28],
# 4 [1, 4, 10, 20, 35, 56, 84]]
# K
# 0 1 2 3 4 5 6
# 1 4
# 1
# 1 0 0 0
# 0 1 0 0
# 0 0 1 0
# 0 0 0 1
# 2
# 2 0 0 0
# 0 2 0 0
# 0 0 2 0
# 0 0 0 2
# 1 1 0 0
# 1 0 1 0
# 1 0 0 1
# 0 1 1 0
# 0 1 0 1
# 0 0 1 1
# 3
# 3 0 0 0
# ~
# 0 0 0 3 -> 4
# 1 1 1 0
# 1 1 0 1
# 1 0 1 1
# 0 1 1 1
# 2 1 0 0
# 2 0 1 0
# 2 0 0 1
# 1 2 0 0
# 0 2 1 0
# 0 2 0 1
# 1 0 2 0
# 0 1 2 0
# 0 0 2 1
# 1 0 0 2
# 0 1 0 2
# 0 0 1 2