# # 새집 크기가 N*N
# # 칸은 (r,c)로 나타낼 수 있음 r = 행번호, c = 열번호
# # 행렬 번호는 1부터 시작, 각각은 빈 칸이거나, 벽
# # 파이프를 옮기려 하는데 파이프는 두 개의 연속된 칸을 먹고 있음(가로로)
# # 파이프는 시계방향으로 45도 각도로 회전 시킬 수 있음 두번 까지
# # 파이프는 밀어서 이동시킬 수 있고, 빈칸만 이동해야 하며, 벽을 긁으면 안된다.
# # 회전은 밀면서만 가능
# # 파이프는 →, ↘, ↓ 방향으로 밀 수 있음, 파이프는 45도 각도로만 회전 가능
# # 파이프가 가로로 놓여지면 이동방향은 우측, 우측아래 대각선 방향 두 가지로 이동 가능
# # 파이프가 새로로 놓여지면 아래, 우측아래 대각선 방향 두 가지로 이동 가능
# # 파이프가 대각선으로 놓여지면, 우측,아래측, 우측아래 세 가지로 이동 가능
# # 처음 파이프가 (1,1),(1,2)를 차지할 때 파이프의 한 끝을 (N,N)으로 이동하는 방법 찾기
#
# # 이동 방향은 우측(0,1)더하기, 아래측(1,0)더하기, 우측아래 대각선 방향(1,1)더하기 세가지 방법이 있음
# # 가로, 세로 일땐 두 방향
# # 대각선일땐 세 방향으로 갈 수 있음
#
#
# import sys
# input = sys.stdin.readline
#
# N = int(input())
#
# map = [list(map(int,input().split())) for _ in range(N)]
# print(map)
# dp = [[0]*N for _ in range(N)]
# # 현재 상태, 가로:0,새로:1,대각선:2
# # start:(행,열,현재 상태)
# start = (0,1,0)
# # 가로: 우측,대각선 새로: 아래,대각선 대각선: 우측,아래,대각선
# status_move = [[(0,1),(1,1)],[(1,0),(1,1)],[(0,1),(1,0),(1,1)]]
# # 들어오는 방향에 따라서 갈 수 있는 경로가 달라짐, 이전 루트에서 해당 지역을 방문 했다고 해서
# def dfs(r,c,status):
#     print(r,c)
#     if r >= N or c >= N or map[r][c] == 1:
#         return 0
#     if r ==N-1 and c == N-1:
#         return 1
#     if dp[r][c]:
#         return dp[r][c]+1
#     for dr,dc in status_move[status]:
#         nr = r+dr
#         nc = c+dc
#         # 우측 이동
#         if dr == 0 and dc == 1:
#             a = dfs(nr, nc,0)
#         # 아래이동
#         elif dr == 1 and dc == 0:
#             a = dfs(nr, nc, 1)
#         # 대각선 이동
#         else:
#             a = dfs(nr,nc,2)
#         dp[r][c]+=a
#         print(dp)
#     return dp[r][c]
# dfs(0,1,0)
# print(dp)
#
#
# # [[0, None, 0],
# #  [0, 0, 1],
# #  [0, 0, 0]]
# # 현재 상태를 나타내야 함

# 각 rc를 모두 순회하면서 해당 노드를 들어올 수 있는 모든 방향을 탐색
# 즉, 왼쪽에서 들어올라면 왼쪽 방향 끝은 대각선이거나, 가로여야하고
# 위에서 해당 노드가 들어오려면, 위 방향 끝은 대각선이거나 세로 방향이어야 한다
# 왼쪽위 즉(r-1,c-1) 자리에서 들어오려면 어떤 방향이어도 대각선으로 들어올 수 있다
# 이렇게 3차원 리스트 dp에 각 방향별 들어오는 방법을 계산하여 저장
# 이렇게 모든 행을 돌면서 결국 n,n자리에 들어올 수 있는 모든 방법들의 합을 계산

import sys

input = sys.stdin.readline

N = int(input())
house = [list(map(int, input().split())) for _ in range(N)]

# DP 배열 초기화 (가로, 세로, 대각선)
dp = [[[0] * 3 for _ in range(N)] for _ in range(N)]

# 초기 위치 설정 (가로 방향으로 시작)
dp[0][1][0] = 1  # (1,2) 위치에서 시작

for r in range(N):
    for c in range(2, N):  # (1,2)에서 시작했으므로 c=2부터 시작
        if house[r][c] == 1:
            continue  # 벽이면 이동 불가

        # 가로 방향 (← →)
        dp[r][c][0] = dp[r][c - 1][0] + dp[r][c - 1][2]

        # 세로 방향 (↑ ↓)
        if r > 0:
            dp[r][c][1] = dp[r - 1][c][1] + dp[r - 1][c][2]

        # 대각선 방향 (↖ ↘)
        if r > 0 and c > 0 and house[r - 1][c] == 0 and house[r][c - 1] == 0:
            dp[r][c][2] = dp[r - 1][c - 1][0] + dp[r - 1][c - 1][1] + dp[r - 1][c - 1][2]

# (N,N) 도착하는 경우의 수 출력
print(sum(dp[N - 1][N - 1]))
